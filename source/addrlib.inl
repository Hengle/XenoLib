/*      AddrLib is a part of GTX Extractor, ported and optimized into C
        languange

        Copyright(C) 2015-2018 AboodXD
        Copyright(C) 2018-2019 Lukas Cone

        This program is free software : you can redistribute it and /or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        This program is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
        GNU General Public License for more details.

        You should have received a copy of the GNU General Public License
        along with this program.If not, see < http://www.gnu.org/licenses/>.
*/

#include <algorithm>
#include "xenolib/mtxt.hpp"

namespace MTXT {
unsigned int computeSurfaceThickness(gx2::TileMode tileMode) {
  using namespace gx2;
  switch (tileMode) {
  case gx2::TileMode::Tiled1DThick:
  case gx2::TileMode::Tiled2DThick:
  case gx2::TileMode::Tiled2BThick:
  case gx2::TileMode::Tiled3DThick:
  case gx2::TileMode::Tiled3BThick:
    return 4;
  case gx2::TileMode::LinearSpecial:
    return 8;
  default:
    return 1;
  }

  return 1;
}

unsigned int computePixelIndexWithinMicroTile(unsigned int x, unsigned int y,
                                              unsigned int bpp) {
  switch (bpp) {
  case 0x8:
    return 32 * ((y & 4) >> 2) | 16 * (y & 1) | 8 * ((y & 2) >> 1) |
           4 * ((x & 4) >> 2) | 2 * ((x & 2) >> 1) | (x & 1);
  case 0x10:
    return 32 * ((y & 4) >> 2) | 16 * ((y & 2) >> 1) | 8 * (y & 1) |
           4 * ((x & 4) >> 2) | 2 * ((x & 2) >> 1) | (x & 1);
  case 0x20:
  case 0x60:
    return 32 * ((y & 4) >> 2) | 16 * ((y & 2) >> 1) | 8 * ((x & 4) >> 2) |
           4 * (y & 1) | 2 * ((x & 2) >> 1) | (x & 1);
  case 0x40:
    return 32 * ((y & 4) >> 2) | 16 * ((y & 2) >> 1) | 8 * ((x & 4) >> 2) |
           4 * ((x & 2) >> 1) | 2 * (y & 1) | (x & 1);
  case 0x80:
    return 32 * ((y & 4) >> 2) | 16 * ((y & 2) >> 1) | 8 * ((x & 4) >> 2) |
           4 * ((x & 2) >> 1) | 2 * (x & 1) | (y & 1);
  default:
    break;
  }

  return 32 * ((y & 4) >> 2) | 16 * ((y & 2) >> 1) | 8 * ((x & 4) >> 2) |
         4 * (y & 1) | 2 * ((x & 2) >> 1) | (x & 1);
}

unsigned int isThickMacroTiled(gx2::TileMode tileMode) {
  using namespace gx2;
  switch (tileMode) {

  case gx2::TileMode::Tiled2DThick:
  case gx2::TileMode::Tiled2BThick:
  case gx2::TileMode::Tiled3DThick:
  case gx2::TileMode::Tiled3BThick:
    return 1;
  default:
    return 0;
  }

  return 0;
}

unsigned int isBankSwappedTileMode(gx2::TileMode tileMode) {
  using namespace gx2;
  switch (tileMode) {
  case gx2::TileMode::Tiled2BThin1:
  case gx2::TileMode::Tiled2BThin2:
  case gx2::TileMode::Tiled2BThin4:
  case gx2::TileMode::Tiled2BThick:
  case gx2::TileMode::Tiled3BThin1:
  case gx2::TileMode::Tiled3BThick:
    return 1;
  default:
    return 0;
  }

  return 0;
}

unsigned int computeMacroTileAspectRatio(gx2::TileMode tileMode) {
  using namespace gx2;
  switch (tileMode) {
  case gx2::TileMode::Tiled2DThin2:
  case gx2::TileMode::Tiled2BThin2:
    return 2;
  case gx2::TileMode::Tiled2DThin4:
  case gx2::TileMode::Tiled2BThin4:
    return 4;
  default:
    return 1;
  }

  return 1;
}

unsigned int computeSurfaceBankSwappedWidth(gx2::TileMode tileMode,
                                            unsigned int bpp,
                                            unsigned int pitch,
                                            unsigned int numSamples) {
  if (!isBankSwappedTileMode(tileMode))
    return 0;

  const unsigned int bytesPerSample = 8 * bpp,
                     slicesPerTile =
                         bytesPerSample
                             ? 1
                             : std::max(1U,
                                        numSamples / (2048 / bytesPerSample));

  if (isThickMacroTiled(tileMode))
    numSamples = 4;

  const unsigned int bytesPerTileSlice =
      numSamples * bytesPerSample / slicesPerTile;
  const unsigned int factor = computeMacroTileAspectRatio(tileMode);
  const unsigned int swapTiles = std::max(1U, 128 / bpp);
  const unsigned int swapWidth = swapTiles * 32;
  const unsigned int heightBytes =
      numSamples * factor * bpp * 2 / slicesPerTile;
  const unsigned int swapMax = 0x4000 / heightBytes;
  const unsigned int swapMin = 256 / bytesPerTileSlice;
  unsigned int bankSwapWidth = std::min(swapMax, std::max(swapMin, swapWidth));

  while (bankSwapWidth >= 2 * pitch)
    bankSwapWidth >>= 1;

  return bankSwapWidth;
}

AddrLibMicroTilePrecomp::AddrLibMicroTilePrecomp(unsigned int _bpp,
                                                 unsigned int pitch,
                                                 gx2::TileMode tileMode)
    : bpp(_bpp) {
  const int microTileThickness =
      tileMode == gx2::TileMode::Tiled1DThick ? 4 : 1;
  microTileBytes = (64 * microTileThickness * _bpp + 7) / 8;
  microTilesPerRow = pitch >> 3;
}

unsigned int
computeSurfaceAddrFromCoordMicroTiled(unsigned int x, unsigned int y,
                                      const AddrLibMicroTilePrecomp &precomp) {
  const unsigned int microTileIndexX = x >> 3;
  const unsigned int microTileIndexY = y >> 3;

  const unsigned int microTileOffset =
      precomp.microTileBytes *
      (microTileIndexX + microTileIndexY * precomp.microTilesPerRow);
  const unsigned int pixelIndex =
      computePixelIndexWithinMicroTile(x, y, precomp.bpp);
  const unsigned int pixelOffset = (precomp.bpp * pixelIndex) >> 3;

  return pixelOffset + microTileOffset;
}

AddrLibMacroTilePrecomp::AddrLibMacroTilePrecomp(
    unsigned int _bpp, unsigned int pitch, unsigned int height,
    gx2::TileMode tileMode, unsigned int pipeSwizzle, unsigned int bankSwizzle)
    : bpp(_bpp) {
  microTileThickness = computeSurfaceThickness(tileMode);
  microTileBits = _bpp * (microTileThickness * 64);
  microTileBytes = (microTileBits + 7) / 8;

  microTileBits = _bpp * (microTileThickness * 64);
  microTileBytes = (microTileBits + 7) / 8;

  if (microTileBytes <= 2048) {
    numSamples = 1;
    sampleSlice = 0;
  } else {
    numSamples = 2048 / microTileBytes;
  }

  swizzle_ = pipeSwizzle + 2 * bankSwizzle;
  sliceBytes =
      (height * pitch * microTileThickness * _bpp * numSamples + 7) / 8;

  macroTileAspectRatio = computeMacroTileAspectRatio(tileMode);
  macroTilePitch = 32 / macroTileAspectRatio;
  macroTileHeight = 16 * macroTileAspectRatio;

  macroTilesPerRow = pitch / macroTilePitch;
  macroTileBytes = (numSamples * microTileThickness * _bpp * macroTileHeight *
                        macroTilePitch +
                    7) /
                   8;

  bankSwapWidth = computeSurfaceBankSwappedWidth(tileMode, _bpp, pitch, 1);

  swappedBank = isBankSwappedTileMode(tileMode);
}

static const unsigned char bankSwapOrder[] = {0, 1, 3, 2, 6, 7, 5, 4, 0, 0};

unsigned int
computeSurfaceAddrFromCoordMacroTiled(unsigned int x, unsigned int y,
                                      const AddrLibMacroTilePrecomp &precomp) {
  unsigned int elemOffset =
      precomp.bpp * computePixelIndexWithinMicroTile(x, y, precomp.bpp);

  if (precomp.microTileBytes > 2048) {
    precomp.sampleSlice = elemOffset / (precomp.microTileBits);
    elemOffset %= precomp.microTileBits;
  }

  elemOffset = (elemOffset + 7) / 8;

  unsigned int pipe = ((y >> 3) ^ (x >> 3)) & 1;
  unsigned int bank =
      (((y >> 5) ^ (x >> 3)) & 1) | (2 * (((y >> 4) ^ (x >> 4)) & 1));

  const unsigned int bankPipe =
      ((pipe + 2 * bank) ^ (6 * precomp.sampleSlice ^ precomp.swizzle_)) % 8;

  pipe = bankPipe % 2;
  bank = bankPipe / 2;

  const unsigned int sliceOffset =
      precomp.sliceBytes * (precomp.sampleSlice / precomp.microTileThickness);

  const unsigned int macroTileIndexX = x / precomp.macroTilePitch;
  const unsigned int macroTileIndexY = y / precomp.macroTileHeight;
  const unsigned int macroTileOffset =
      (macroTileIndexX + precomp.macroTilesPerRow * macroTileIndexY) *
      precomp.macroTileBytes;

  if (precomp.swappedBank) {
    const unsigned int swapIndex =
        precomp.macroTilePitch * macroTileIndexX / precomp.bankSwapWidth;
    bank ^= bankSwapOrder[swapIndex & 3];
  }

  const unsigned int totalOffset =
      elemOffset + ((macroTileOffset + sliceOffset) >> 3);
  return (bank << 9) | (pipe << 8) | (255 & totalOffset) |
         ((totalOffset & -256) << 3);
}
} // namespace MTXT
